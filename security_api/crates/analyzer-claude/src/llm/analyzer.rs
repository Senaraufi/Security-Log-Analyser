use async_trait::async_trait;
use serde::{Deserialize, Serialize};
use std::env;

use security_common::parsers::apache::ApacheLog;

/// Security report generated by LLM analysis
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecurityReport {
    pub summary: String,
    pub threat_level: ThreatLevel,
    pub findings: Vec<Finding>,
    pub attack_chains: Vec<AttackChain>,
    pub recommendations: Vec<String>,
    pub iocs: Vec<IOC>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum ThreatLevel {
    Critical,
    High,
    Medium,
    Low,
    None,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Finding {
    pub severity: String,
    pub attack_type: String,
    pub description: String,
    pub affected_resources: Vec<String>,
    pub confidence: f32, // 0.0 to 1.0
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AttackChain {
    pub name: String,
    pub description: String,
    pub events: Vec<String>,
    pub timeline: Vec<String>,
    pub source_ips: Vec<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IOC {
    pub ioc_type: String, // "ip", "user_agent", "path", "pattern"
    pub value: String,
    pub description: String,
}

/// Trait for LLM analyzers (allows swapping between real API and mock)
#[async_trait]
pub trait LLMAnalyzer: Send + Sync {
    async fn analyze_logs(&self, logs: Vec<ApacheLog>) -> Result<SecurityReport, String>;
}

/// Claude API analyzer (real implementation)
pub struct ClaudeAnalyzer {
    api_key: Option<String>,
    model: String,
}

impl ClaudeAnalyzer {
    pub fn new() -> Self {
        let api_key = env::var("ANTHROPIC_API_KEY").ok();
        
        Self {
            api_key,
            model: "claude-3-5-sonnet-20241022".to_string(),
        }
    }
    
    pub fn is_configured(&self) -> bool {
        self.api_key.is_some()
    }
    
    async fn call_claude_api(&self, prompt: String) -> Result<String, String> {
        let api_key = self.api_key.as_ref()
            .ok_or("ANTHROPIC_API_KEY not set")?;
        
        let client = reqwest::Client::new();
        
        #[derive(Serialize)]
        struct ClaudeRequest {
            model: String,
            max_tokens: u32,
            messages: Vec<Message>,
        }
        
        #[derive(Serialize)]
        struct Message {
            role: String,
            content: String,
        }
        
        #[derive(Deserialize)]
        struct ClaudeResponse {
            content: Vec<ContentBlock>,
        }
        
        #[derive(Deserialize)]
        struct ContentBlock {
            text: String,
        }
        
        let request = ClaudeRequest {
            model: self.model.clone(),
            max_tokens: 4096,
            messages: vec![Message {
                role: "user".to_string(),
                content: prompt,
            }],
        };
        
        let response = client
            .post("https://api.anthropic.com/v1/messages")
            .header("x-api-key", api_key)
            .header("anthropic-version", "2023-06-01")
            .header("content-type", "application/json")
            .json(&request)
            .send()
            .await
            .map_err(|e| format!("API request failed: {}", e))?;
        
        if !response.status().is_success() {
            let status = response.status();
            let error_text = response.text().await.unwrap_or_default();
            return Err(format!("API error {}: {}", status, error_text));
        }
        
        let claude_response: ClaudeResponse = response
            .json()
            .await
            .map_err(|e| format!("Failed to parse response: {}", e))?;
        
        claude_response.content
            .first()
            .map(|block| block.text.clone())
            .ok_or("Empty response from Claude".to_string())
    }
    
    fn parse_claude_response(&self, response: String) -> Result<SecurityReport, String> {
        // Try to parse as JSON first (if we ask Claude to return JSON)
        if let Ok(report) = serde_json::from_str::<SecurityReport>(&response) {
            return Ok(report);
        }
        
        // Otherwise, parse the text response
        // This is a simple parser - you can make it more sophisticated
        let lines: Vec<&str> = response.lines().collect();
        
        let mut summary = String::new();
        let mut findings = Vec::new();
        let mut recommendations = Vec::new();
        let mut iocs = Vec::new();
        
        let mut current_section = "";
        
        for line in lines {
            let line = line.trim();
            if line.is_empty() {
                continue;
            }
            
            if line.to_lowercase().contains("summary") {
                current_section = "summary";
                continue;
            } else if line.to_lowercase().contains("finding") {
                current_section = "findings";
                continue;
            } else if line.to_lowercase().contains("recommendation") {
                current_section = "recommendations";
                continue;
            } else if line.to_lowercase().contains("ioc") {
                current_section = "iocs";
                continue;
            }
            
            match current_section {
                "summary" => {
                    if !summary.is_empty() {
                        summary.push(' ');
                    }
                    summary.push_str(line);
                }
                "findings" => {
                    if line.starts_with('-') || line.starts_with('•') {
                        findings.push(Finding {
                            severity: "Medium".to_string(),
                            attack_type: "Unknown".to_string(),
                            description: line.trim_start_matches('-').trim_start_matches('•').trim().to_string(),
                            affected_resources: vec![],
                            confidence: 0.8,
                        });
                    }
                }
                "recommendations" => {
                    if line.starts_with('-') || line.starts_with('•') {
                        recommendations.push(line.trim_start_matches('-').trim_start_matches('•').trim().to_string());
                    }
                }
                _ => {}
            }
        }
        
        // Determine threat level based on findings
        let threat_level = if findings.iter().any(|f| f.severity == "Critical") {
            ThreatLevel::Critical
        } else if findings.iter().any(|f| f.severity == "High") {
            ThreatLevel::High
        } else if findings.iter().any(|f| f.severity == "Medium") {
            ThreatLevel::Medium
        } else if !findings.is_empty() {
            ThreatLevel::Low
        } else {
            ThreatLevel::None
        };
        
        Ok(SecurityReport {
            summary: if summary.is_empty() { response.clone() } else { summary },
            threat_level,
            findings,
            attack_chains: vec![],
            recommendations,
            iocs,
        })
    }
}

#[async_trait]
impl LLMAnalyzer for ClaudeAnalyzer {
    async fn analyze_logs(&self, logs: Vec<ApacheLog>) -> Result<SecurityReport, String> {
        if !self.is_configured() {
            return Err("Claude API key not configured. Set ANTHROPIC_API_KEY environment variable.".to_string());
        }
        
        // Build the prompt using our prompt builder
        let prompt = crate::llm::prompts::PromptBuilder::new()
            .with_logs(&logs)
            .build_security_analysis();
        
        // Call Claude API
        let response = self.call_claude_api(prompt).await?;
        
        // Parse response into structured report
        self.parse_claude_response(response)
    }
}

impl Default for ClaudeAnalyzer {
    fn default() -> Self {
        Self::new()
    }
}
