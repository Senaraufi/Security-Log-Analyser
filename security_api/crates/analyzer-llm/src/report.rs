//! Security report structures for LLM-based log analysis.
//!
//! This module defines the `SecurityReport` and related structures that
//! are returned from the LLM analysis. These structures are designed to
//! be JSON-serializable and compatible with the frontend UI.

use serde::{Deserialize, Serialize};

/// Comprehensive security analysis report generated by the LLM
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SecurityReport {
    /// Executive summary of the security analysis
    pub summary: String,
    
    /// Overall threat level: Critical, High, Medium, Low, or Info
    pub threat_level: String,
    
    /// Total number of logs that were analyzed
    pub total_logs_analyzed: usize,
    
    /// Number of logs identified as suspicious or malicious
    pub suspicious_logs_count: usize,
    
    /// Identified attack chains with descriptions
    #[serde(default)]
    pub attack_chains: Vec<String>,
    
    /// MITRE ATT&CK technique mappings with T-codes
    #[serde(default)]
    pub mitre_attack_techniques: Vec<String>,
    
    /// Indicators of Compromise (IOCs) found in the logs
    #[serde(default)]
    pub indicators_of_compromise: Vec<String>,
    
    /// Actionable security recommendations
    #[serde(default)]
    pub recommendations: Vec<String>,
    
    /// Confidence score for the analysis (0.0 - 1.0)
    #[serde(default = "default_confidence")]
    pub confidence_score: f32,
    
    /// Critical alerts requiring immediate attention
    #[serde(default)]
    pub alerts: Vec<String>,
}

fn default_confidence() -> f32 {
    0.75
}

impl SecurityReport {
    /// Create an empty report (for when no logs are provided)
    pub fn empty() -> Self {
        Self {
            summary: "No logs provided for analysis.".to_string(),
            threat_level: "Info".to_string(),
            total_logs_analyzed: 0,
            suspicious_logs_count: 0,
            attack_chains: Vec::new(),
            mitre_attack_techniques: Vec::new(),
            indicators_of_compromise: Vec::new(),
            recommendations: vec!["Provide log data for security analysis.".to_string()],
            confidence_score: 1.0,
            alerts: Vec::new(),
        }
    }

    /// Create a fallback report when LLM response parsing fails
    pub fn fallback(raw_response: &str, total_logs: usize) -> Self {
        // Extract a summary from the first few lines of the response
        let summary: String = raw_response
            .lines()
            .take(5)
            .collect::<Vec<_>>()
            .join(" ")
            .chars()
            .take(500)
            .collect();

        Self {
            summary: if summary.is_empty() {
                "Analysis completed but response could not be fully parsed.".to_string()
            } else {
                summary
            },
            threat_level: "Medium".to_string(),
            total_logs_analyzed: total_logs,
            suspicious_logs_count: 0,
            attack_chains: Vec::new(),
            mitre_attack_techniques: Vec::new(),
            indicators_of_compromise: Vec::new(),
            recommendations: vec![
                "Review the raw AI analysis for detailed findings.".to_string(),
                "Consider re-running the analysis if results are incomplete.".to_string(),
            ],
            confidence_score: 0.5,
            alerts: vec!["Analysis response could not be fully parsed. Review raw output.".to_string()],
        }
    }

    /// Check if this report indicates critical threats
    pub fn is_critical(&self) -> bool {
        self.threat_level.eq_ignore_ascii_case("critical")
    }

    /// Check if this report indicates high or critical threats
    pub fn is_high_severity(&self) -> bool {
        let level = self.threat_level.to_lowercase();
        level == "critical" || level == "high"
    }

    /// Get the number of IOCs found
    pub fn ioc_count(&self) -> usize {
        self.indicators_of_compromise.len()
    }

    /// Get the number of MITRE techniques identified
    pub fn technique_count(&self) -> usize {
        self.mitre_attack_techniques.len()
    }

    /// Extract malicious IPs from the IOCs
    pub fn malicious_ips(&self) -> Vec<String> {
        self.indicators_of_compromise
            .iter()
            .filter(|ioc| ioc.to_lowercase().contains("malicious ip") || ioc.to_lowercase().contains("ip:"))
            .filter_map(|ioc| {
                // Try to extract IP address pattern
                let ip_pattern = regex::Regex::new(r"\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}").ok()?;
                ip_pattern.find(ioc).map(|m| m.as_str().to_string())
            })
            .collect()
    }
}

/// Detailed IP analysis report
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct IpAnalysisReport {
    /// The IP address analyzed
    pub ip: String,
    
    /// Classification: malicious, suspicious, or benign
    pub classification: String,
    
    /// Risk score from 0.0 (safe) to 1.0 (definitely malicious)
    pub risk_score: f32,
    
    /// Types of attacks detected from this IP
    #[serde(default)]
    pub attack_types: Vec<String>,
    
    /// Total number of requests from this IP
    pub request_count: usize,
    
    /// Number of suspicious requests
    pub suspicious_requests: usize,
    
    /// First seen timestamp
    pub first_seen: Option<String>,
    
    /// Last seen timestamp
    pub last_seen: Option<String>,
    
    /// User agents used by this IP
    #[serde(default)]
    pub user_agents: Vec<String>,
    
    /// Paths targeted by this IP
    #[serde(default)]
    pub targeted_paths: Vec<String>,
    
    /// Recommended actions for this IP
    #[serde(default)]
    pub recommendations: Vec<String>,
    
    /// Evidence supporting the classification
    pub evidence: Option<String>,
}

impl IpAnalysisReport {
    /// Check if this IP should be blocked
    pub fn should_block(&self) -> bool {
        self.classification == "malicious" || self.risk_score >= 0.8
    }

    /// Check if this IP requires investigation
    pub fn requires_investigation(&self) -> bool {
        self.classification == "suspicious" || self.risk_score >= 0.5
    }
}

/// Quick triage report for rapid threat assessment
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct TriageReport {
    /// Overall threat level
    pub threat_level: String,
    
    /// Most critical findings
    #[serde(default)]
    pub critical_findings: Vec<String>,
    
    /// Top malicious IPs to block
    #[serde(default)]
    pub top_malicious_ips: Vec<String>,
    
    /// Actions to take immediately
    #[serde(default)]
    pub immediate_actions: Vec<String>,
    
    /// Whether a deeper analysis is recommended
    #[serde(default)]
    pub requires_deep_analysis: bool,
}

/// Detailed recommendations report
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct RecommendationsReport {
    /// Actions to take immediately
    #[serde(default)]
    pub immediate_actions: Vec<ActionItem>,
    
    /// Actions to take in the short term
    #[serde(default)]
    pub short_term_actions: Vec<ActionItem>,
    
    /// Long-term security improvements
    #[serde(default)]
    pub long_term_improvements: Vec<ActionItem>,
    
    /// Ongoing monitoring recommendations
    #[serde(default)]
    pub monitoring_recommendations: Vec<String>,
}

/// A single actionable recommendation item
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct ActionItem {
    /// Priority level (1 = highest)
    pub priority: u8,
    
    /// The action to take
    pub action: String,
    
    /// Why this action is important
    pub reason: String,
    
    /// How to implement this action
    pub implementation: String,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_empty_report() {
        let report = SecurityReport::empty();
        
        assert_eq!(report.total_logs_analyzed, 0);
        assert_eq!(report.threat_level, "Info");
        assert_eq!(report.confidence_score, 1.0);
    }

    #[test]
    fn test_fallback_report() {
        let report = SecurityReport::fallback("Some analysis text here", 100);
        
        assert_eq!(report.total_logs_analyzed, 100);
        assert_eq!(report.threat_level, "Medium");
        assert_eq!(report.confidence_score, 0.5);
        assert!(report.summary.contains("Some analysis"));
    }

    #[test]
    fn test_severity_checks() {
        let mut report = SecurityReport::empty();
        
        report.threat_level = "Critical".to_string();
        assert!(report.is_critical());
        assert!(report.is_high_severity());
        
        report.threat_level = "High".to_string();
        assert!(!report.is_critical());
        assert!(report.is_high_severity());
        
        report.threat_level = "Medium".to_string();
        assert!(!report.is_critical());
        assert!(!report.is_high_severity());
    }

    #[test]
    fn test_deserialize_report() {
        let json = r#"{
            "summary": "Test summary",
            "threat_level": "High",
            "total_logs_analyzed": 100,
            "suspicious_logs_count": 25,
            "attack_chains": ["Chain 1"],
            "mitre_attack_techniques": ["T1190 - Test"],
            "indicators_of_compromise": ["Malicious IP: 10.0.0.1"],
            "recommendations": ["Block IP"],
            "confidence_score": 0.9,
            "alerts": []
        }"#;

        let report: SecurityReport = serde_json::from_str(json).unwrap();
        
        assert_eq!(report.threat_level, "High");
        assert_eq!(report.total_logs_analyzed, 100);
        assert_eq!(report.suspicious_logs_count, 25);
        assert_eq!(report.confidence_score, 0.9);
    }

    #[test]
    fn test_deserialize_minimal_report() {
        // Test that default values work
        let json = r#"{
            "summary": "Minimal test",
            "threat_level": "Low",
            "total_logs_analyzed": 10,
            "suspicious_logs_count": 0
        }"#;

        let report: SecurityReport = serde_json::from_str(json).unwrap();
        
        assert_eq!(report.threat_level, "Low");
        assert!(report.attack_chains.is_empty());
        assert_eq!(report.confidence_score, 0.75); // default value
    }

    #[test]
    fn test_ip_analysis_report() {
        let report = IpAnalysisReport {
            ip: "10.0.0.1".to_string(),
            classification: "malicious".to_string(),
            risk_score: 0.95,
            attack_types: vec!["SQL Injection".to_string()],
            request_count: 150,
            suspicious_requests: 120,
            first_seen: Some("2024-01-15T10:00:00Z".to_string()),
            last_seen: Some("2024-01-15T12:00:00Z".to_string()),
            user_agents: vec!["sqlmap/1.0".to_string()],
            targeted_paths: vec!["/api/users".to_string()],
            recommendations: vec!["Block immediately".to_string()],
            evidence: Some("Multiple SQL injection attempts".to_string()),
        };

        assert!(report.should_block());
        assert!(report.requires_investigation());
    }
}