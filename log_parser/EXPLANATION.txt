================================================================================
                    SECURITY LOG PARSER - COMPLETE EXPLANATION
================================================================================

This document explains in detail how the log parser works, what each part does,
and the logic behind the implementation.

================================================================================
1. OVERVIEW
================================================================================

The log parser is a security analysis tool that:
  - Reads security log files line by line
  - Extracts structured data (timestamps, IPs, usernames, severity levels)
  - Detects 4 types of security threats
  - Tracks IP address frequency to identify attackers
  - Calculates overall risk level
  - Generates a comprehensive security report

Input:  sample_logs.txt (raw log file)
Output: Security analysis report with threat statistics

================================================================================
2. PROGRAM STRUCTURE
================================================================================

The program has 3 main components:

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 1. DATA STRUCTURE (LogEntry struct)                            â”‚
â”‚    Defines what information we extract from each log line      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 2. MAIN FUNCTION (main)                                         â”‚
â”‚    - Opens the log file                                         â”‚
â”‚    - Processes each line                                        â”‚
â”‚    - Runs threat detection rules                               â”‚
â”‚    - Generates the final report                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                              â”‚
                              â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 3. PARSING FUNCTION (parse_log_line)                            â”‚
â”‚    Takes a raw log line and extracts structured data           â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

================================================================================
3. IMPORTS AND DEPENDENCIES
================================================================================

use regex::Regex;
  â†’ Provides pattern matching capabilities for finding IPs, timestamps, etc.
  â†’ Example: Finding "192.168.1.100" in a log message

use std::fs::File;
  â†’ Allows opening files from the filesystem
  â†’ Used to open "sample_logs.txt"

use std::io::{BufRead, BufReader};
  â†’ BufReader: Reads files efficiently in chunks (buffered reading)
  â†’ BufRead: Trait that provides the .lines() method
  â†’ Much faster than reading byte-by-byte for large files

use std::collections::HashMap;
  â†’ Key-value storage for counting IP occurrences
  â†’ Example: {"192.168.1.100": 5, "10.0.0.50": 1}
  â†’ O(1) lookup time (very fast)

================================================================================
4. DATA STRUCTURE: LogEntry
================================================================================

#[derive(Debug)]
struct LogEntry {
    timestamp: String,
    level: String,
    ip_address: Option<String>,
    username: Option<String>,
    message: String,
}

WHAT IT DOES:
  Defines a template for storing parsed log data. Think of it as a container
  that holds all the important pieces of information from one log line.

FIELDS EXPLAINED:

  timestamp: String
    â†’ The date and time when the event occurred
    â†’ Example: "2024-01-15 10:30:45"
    â†’ Type: String (always present)

  level: String
    â†’ The severity level of the log entry
    â†’ Example: "ERROR", "INFO", "WARN", "CRITICAL"
    â†’ Type: String (always present)

  ip_address: Option<String>
    â†’ The IP address involved in the event (if any)
    â†’ Example: Some("192.168.1.100") or None
    â†’ Type: Option<String> because not all logs have IPs

  username: Option<String>
    â†’ The username involved in the event (if any)
    â†’ Example: Some("admin") or None
    â†’ Type: Option<String> because not all logs have usernames

  message: String
    â†’ The full log message text
    â†’ Example: "Failed login attempt from 192.168.1.100 user: admin"
    â†’ Type: String (always present)

WHY USE Option<T>?
  Option<T> is Rust's way of handling values that might not exist.
  It can be either:
    - Some(value) â†’ The value exists
    - None        â†’ The value doesn't exist
  
  This is safer than null pointers because the compiler forces you to
  handle both cases.

#[derive(Debug)]
  This automatically generates code that lets you print the struct for
  debugging. That's why we can use {:?} in println!

================================================================================
5. MAIN FUNCTION - STEP BY STEP
================================================================================

STEP 1: INITIALIZATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

println!("Security Log Parser - Starting Analysis\n");

  â†’ Prints a header message to show the program is running

let file = File::open("sample_logs.txt").expect("Failed to open log file");

  â†’ File::open() attempts to open the file
  â†’ Returns Result<File, Error>
  â†’ .expect() unwraps the Result:
      - If Ok(file): continues with the file
      - If Err: crashes with the error message
  â†’ In production, you'd use proper error handling instead of .expect()

let reader = BufReader::new(file);

  â†’ Wraps the file in a BufReader for efficient reading
  â†’ BufReader reads in chunks (e.g., 8KB at a time) instead of byte-by-byte
  â†’ This is MUCH faster for large log files
  â†’ Provides the .lines() method for iterating over lines


STEP 2: INITIALIZE TRACKING VARIABLES
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

let mut failed_logins = 0;
let mut root_attempts = 0;
let mut suspicious_file_access = 0;
let mut critical_alerts = 0;

  â†’ Counters for different types of threats
  â†’ 'mut' means mutable (we can change these values)
  â†’ All start at 0 and increment when threats are detected

let mut ip_frequency: HashMap<String, usize> = HashMap::new();

  â†’ HashMap to count how many times each IP appears
  â†’ Key: IP address (String)
  â†’ Value: count (usize - unsigned integer)
  â†’ Example after processing:
      {
        "192.168.1.100": 5,
        "203.0.113.45": 2,
        "10.0.0.50": 1
      }


STEP 3: PROCESS EACH LOG LINE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

for line in reader.lines() {

  â†’ reader.lines() returns an iterator over each line
  â†’ Each line is wrapped in Result<String, Error>
  â†’ The for loop processes one line at a time

    if let Ok(log_line) = line {

      â†’ Unwraps the Result
      â†’ If Ok(log_line): continues with the line content
      â†’ If Err: skips this line (file read error)
      â†’ This is safe error handling - we don't crash on bad lines

        if let Some(entry) = parse_log_line(&log_line) {

          â†’ Calls parse_log_line() to extract structured data
          â†’ Returns Option<LogEntry>
          â†’ If Some(entry): parsing succeeded, continue
          â†’ If None: parsing failed (malformed line), skip it

            println!("ğŸ“‹ Parsed: {:?}", entry);

              â†’ Prints the parsed entry for debugging
              â†’ {:?} uses the Debug format (from #[derive(Debug)])


STEP 4: THREAT DETECTION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

            if let Some(ip) = &entry.ip_address {
                ip_frequency.entry(ip.clone())
                    .and_modify(|count| *count += 1)
                    .or_insert(1);
            }

  WHAT THIS DOES:
    Tracks how many times each IP address appears in the logs

  LINE BY LINE:
    if let Some(ip) = &entry.ip_address {
      â†’ Checks if this log entry has an IP address
      â†’ &entry.ip_address borrows the IP (doesn't take ownership)
      â†’ Only runs if IP exists

    ip_frequency.entry(ip.clone())
      â†’ Gets or creates an entry in the HashMap for this IP
      â†’ .clone() creates a copy of the IP string (needed for ownership)

    .and_modify(|count| *count += 1)
      â†’ If the IP already exists in the HashMap, increment its count
      â†’ |count| is a closure (anonymous function)
      â†’ *count += 1 dereferences and increments

    .or_insert(1);
      â†’ If the IP doesn't exist, insert it with count = 1
      â†’ This is the "entry API" pattern - very efficient!

  EXAMPLE:
    First time seeing 192.168.1.100: {"192.168.1.100": 1}
    Second time:                     {"192.168.1.100": 2}
    Third time:                      {"192.168.1.100": 3}


DETECTION RULE 1: FAILED LOGIN ATTEMPTS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

            if entry.level == "ERROR" && entry.message.contains("Failed login") {
                failed_logins += 1;
            }

  WHAT IT DETECTS:
    Failed authentication attempts (common in brute force attacks)

  CONDITIONS:
    1. entry.level == "ERROR" â†’ Log level must be ERROR
    2. entry.message.contains("Failed login") â†’ Message must contain this text
    3. Both conditions must be true (&&)

  EXAMPLE MATCH:
    [ERROR] Failed login attempt from 192.168.1.100 user: admin
    âœ… Level is ERROR
    âœ… Contains "Failed login"
    â†’ failed_logins counter increments


DETECTION RULE 2: ROOT USER ACCESS ATTEMPTS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

            if entry.message.contains("user: root") {
                root_attempts += 1;
                println!("âš ï¸  Root access attempt detected: {}", entry.message);
            }

  WHAT IT DETECTS:
    Any attempt to access the root/administrator account

  WHY IT MATTERS:
    - Root has full system control
    - Attackers often target root accounts
    - Even one root attempt is suspicious

  EXAMPLE MATCH:
    Failed login attempt from 192.168.1.100 user: root
    âœ… Contains "user: root"
    â†’ root_attempts counter increments
    â†’ Prints immediate warning


DETECTION RULE 3: SUSPICIOUS FILE ACCESS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

            if entry.message.contains("/etc/passwd") || 
               entry.message.contains("/etc/shadow") ||
               entry.message.contains("Suspicious file") {
                suspicious_file_access += 1;
                println!("ğŸ” Suspicious file access: {}", entry.message);
            }

  WHAT IT DETECTS:
    Access to sensitive system files

  FILES MONITORED:
    /etc/passwd â†’ Contains user account information
    /etc/shadow â†’ Contains encrypted passwords
    "Suspicious file" â†’ Pre-flagged suspicious activity

  WHY IT MATTERS:
    - These files contain credentials
    - Attackers read them for privilege escalation
    - Normal users shouldn't access these

  LOGIC:
    || means OR â†’ Matches if ANY condition is true


DETECTION RULE 4: CRITICAL ALERTS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

            if entry.level == "CRITICAL" {
                critical_alerts += 1;
                println!("ğŸš¨ CRITICAL ALERT: {}", entry.message);
            }

  WHAT IT DETECTS:
    The highest severity events

  EXAMPLE:
    [CRITICAL] System compromise detected
    [CRITICAL] Brute force attack detected

  ACTION:
    Prints immediate alert for manual review


STEP 5: GENERATE ANALYSIS REPORT
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    println!("\n{}", "=".repeat(60));
    println!("ğŸ“Š SECURITY ANALYSIS SUMMARY");
    println!("{}", "=".repeat(60));

  â†’ Prints a formatted header
  â†’ "=".repeat(60) creates a line of 60 equal signs

    println!("\nğŸ”¢ Threat Statistics:");
    println!("   Failed login attempts: {}", failed_logins);
    println!("   Root user attempts: {}", root_attempts);
    println!("   Suspicious file access: {}", suspicious_file_access);
    println!("   Critical alerts: {}", critical_alerts);

  â†’ Displays counts for each threat type
  â†’ {} is a placeholder that gets replaced with the variable value


IP FREQUENCY ANALYSIS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let mut ip_vec: Vec<_> = ip_frequency.iter().collect();

  â†’ Converts HashMap to a Vector of (IP, count) tuples
  â†’ Why? HashMaps are unordered, we need to sort them
  â†’ Vec<_> means "vector of whatever type .collect() produces"
  â†’ .iter() creates an iterator over the HashMap
  â†’ .collect() gathers the items into a vector

    ip_vec.sort_by(|a, b| b.1.cmp(a.1));

  â†’ Sorts the vector by count (highest first)
  â†’ |a, b| is a closure that compares two items
  â†’ b.1.cmp(a.1) compares counts in descending order
  â†’ .1 accesses the second element of the tuple (the count)
  â†’ Result: IPs with most occurrences appear first


HIGH-RISK IP IDENTIFICATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let high_risk_ips: Vec<_> = ip_vec.iter()
        .filter(|(_, count)| **count >= 3)
        .collect();

  â†’ Filters for IPs with 3 or more occurrences
  â†’ .filter() keeps only items that match the condition
  â†’ (_, count) destructures the tuple (ignore IP, use count)
  â†’ **count dereferences twice (once for reference, once for &&)
  â†’ >= 3 is the threshold for "high risk"

    if high_risk_ips.is_empty() {
        println!("   âœ… No high-risk IPs detected (3+ occurrences)");
    } else {
        println!("   ğŸš¨ High-Risk IPs (3+ occurrences):");
        for (ip, count) in high_risk_ips {
            println!("      {} - {} occurrences", ip, count);
        }
    }

  â†’ Checks if any high-risk IPs were found
  â†’ If none: prints success message
  â†’ If some: lists each one with its count


ALL IP ACTIVITY
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    for (ip, count) in ip_vec {
        let risk_indicator = if *count >= 3 { "ğŸ”´" } else { "ğŸŸ¢" };
        println!("      {} {} - {} occurrences", risk_indicator, ip, count);
    }

  â†’ Shows all IPs with visual risk indicators
  â†’ ğŸ”´ Red circle for high-risk (3+)
  â†’ ğŸŸ¢ Green circle for normal (1-2)


RISK LEVEL CALCULATION
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let total_threats = failed_logins + root_attempts + 
                        suspicious_file_access + critical_alerts;

  â†’ Sums all threat counters to get total risk score

    let risk_level = if total_threats >= 10 {
        "ğŸ”´ HIGH - Immediate action required"
    } else if total_threats >= 5 {
        "ğŸŸ¡ MEDIUM - Monitor closely"
    } else {
        "ğŸŸ¢ LOW - Normal activity"
    };

  â†’ Categorizes overall risk based on total threats
  â†’ HIGH: 10+ threats (serious attack likely)
  â†’ MEDIUM: 5-9 threats (suspicious activity)
  â†’ LOW: 0-4 threats (normal operations)

    println!("   {}", risk_level);
    println!("   Total threat indicators: {}", total_threats);

  â†’ Displays the risk assessment

================================================================================
6. PARSING FUNCTION: parse_log_line
================================================================================

fn parse_log_line(line: &str) -> Option<LogEntry> {

FUNCTION SIGNATURE:
  - Takes: &str (borrowed string slice - the raw log line)
  - Returns: Option<LogEntry> (Some if parsing succeeded, None if failed)
  - &str means we borrow the string (don't take ownership)


STEP 1: EXTRACT TIMESTAMP, LEVEL, AND MESSAGE
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let re = Regex::new(
        r"(?P<timestamp>\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2}) \[(?P<level>\w+)\] (?P<message>.*)"
    ).ok()?;

  WHAT IT DOES:
    Creates a regex pattern to match the log format

  PATTERN BREAKDOWN:
    (?P<timestamp>...)  â†’ Named capture group called "timestamp"
    \d{4}-\d{2}-\d{2}   â†’ Matches YYYY-MM-DD (e.g., 2024-01-15)
    (space)             â†’ Literal space
    \d{2}:\d{2}:\d{2}   â†’ Matches HH:MM:SS (e.g., 10:30:45)
    (space)             â†’ Literal space
    \[                  â†’ Literal [ bracket (escaped)
    (?P<level>\w+)      â†’ Named group "level", matches word characters
    \]                  â†’ Literal ] bracket
    (space)             â†’ Literal space
    (?P<message>.*)     â†’ Named group "message", matches everything after

  EXAMPLE MATCH:
    Input:  "2024-01-15 10:30:45 [ERROR] Failed login attempt"
    Groups: timestamp = "2024-01-15 10:30:45"
            level     = "ERROR"
            message   = "Failed login attempt"

  .ok()?
    â†’ Regex::new() returns Result<Regex, Error>
    â†’ .ok() converts Result to Option
    â†’ ? returns None if regex creation failed

    let caps = re.captures(line)?;

  â†’ Tries to match the regex against the log line
  â†’ Returns Option<Captures>
  â†’ ? returns None if no match (malformed log line)

    let message = caps.name("message")?.as_str();

  â†’ Extracts the "message" capture group
  â†’ .name("message") gets the named group
  â†’ ? returns None if group doesn't exist
  â†’ .as_str() converts to string slice


STEP 2: EXTRACT IP ADDRESS
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let ip_re = Regex::new(r"\b(?:\d{1,3}\.){3}\d{1,3}\b").ok()?;

  PATTERN BREAKDOWN:
    \b                  â†’ Word boundary (start of IP)
    (?:\d{1,3}\.){3}    â†’ 1-3 digits + dot, repeated 3 times
    \d{1,3}             â†’ 1-3 digits (last octet)
    \b                  â†’ Word boundary (end of IP)

  MATCHES:
    âœ… 192.168.1.100
    âœ… 10.0.0.50
    âœ… 203.0.113.45
    âŒ 999.999.999.999 (would match pattern but invalid IP)

    let ip_address = ip_re.find(message).map(|m| m.as_str().to_string());

  â†’ Searches for IP pattern in the message
  â†’ .find() returns Option<Match>
  â†’ .map() transforms Match to String if found
  â†’ If no IP found, ip_address = None


STEP 3: EXTRACT USERNAME
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    let user_re = Regex::new(r"user: (\S+)").ok()?;

  PATTERN:
    user:  â†’ Literal text "user:"
    (\S+)  â†’ Capture group: one or more non-whitespace characters

  MATCHES:
    "user: admin"     â†’ Captures "admin"
    "user: john.doe"  â†’ Captures "john.doe"
    "user: root"      â†’ Captures "root"

    let username = user_re.captures(message)
        .and_then(|c| c.get(1))
        .map(|m| m.as_str().to_string());

  CHAIN EXPLANATION:
    user_re.captures(message)
      â†’ Try to match the pattern, returns Option<Captures>

    .and_then(|c| c.get(1))
      â†’ If match succeeded, get capture group 1 (the username)
      â†’ .and_then() chains Option operations
      â†’ Returns Option<Match>

    .map(|m| m.as_str().to_string())
      â†’ If capture group exists, convert to String
      â†’ Returns Option<String>

  RESULT:
    If username found: Some("admin")
    If not found: None


STEP 4: BUILD AND RETURN LogEntry
â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

    Some(LogEntry {
        timestamp: caps.name("timestamp")?.as_str().to_string(),
        level: caps.name("level")?.as_str().to_string(),
        ip_address,
        username,
        message: message.to_string(),
    })

  â†’ Creates a new LogEntry struct with all extracted data
  â†’ Wraps it in Some() to indicate success
  â†’ If any ? operator fails, function returns None early
  â†’ ip_address and username are already Option<String>, so we use them directly

================================================================================
7. CONTROL FLOW DIAGRAM
================================================================================

START
  â”‚
  â”œâ”€ Open sample_logs.txt
  â”‚
  â”œâ”€ Initialize counters (failed_logins, root_attempts, etc.)
  â”‚
  â”œâ”€ Initialize HashMap (ip_frequency)
  â”‚
  â””â”€ FOR EACH line in file:
       â”‚
       â”œâ”€ IF line read successfully:
       â”‚    â”‚
       â”‚    â””â”€ CALL parse_log_line(line)
       â”‚         â”‚
       â”‚         â”œâ”€ IF parsing succeeded:
       â”‚         â”‚    â”‚
       â”‚         â”‚    â”œâ”€ Print parsed entry
       â”‚         â”‚    â”‚
       â”‚         â”‚    â”œâ”€ IF IP exists:
       â”‚         â”‚    â”‚    â””â”€ Update ip_frequency HashMap
       â”‚         â”‚    â”‚
       â”‚         â”‚    â”œâ”€ IF failed login:
       â”‚         â”‚    â”‚    â””â”€ Increment failed_logins
       â”‚         â”‚    â”‚
       â”‚         â”‚    â”œâ”€ IF root user attempt:
       â”‚         â”‚    â”‚    â”œâ”€ Increment root_attempts
       â”‚         â”‚    â”‚    â””â”€ Print warning
       â”‚         â”‚    â”‚
       â”‚         â”‚    â”œâ”€ IF suspicious file access:
       â”‚         â”‚    â”‚    â”œâ”€ Increment suspicious_file_access
       â”‚         â”‚    â”‚    â””â”€ Print warning
       â”‚         â”‚    â”‚
       â”‚         â”‚    â””â”€ IF critical alert:
       â”‚         â”‚         â”œâ”€ Increment critical_alerts
       â”‚         â”‚         â””â”€ Print alert
       â”‚         â”‚
       â”‚         â””â”€ IF parsing failed:
       â”‚              â””â”€ Skip this line
       â”‚
       â””â”€ IF line read failed:
            â””â”€ Skip this line
  
  â”œâ”€ Calculate total_threats
  â”‚
  â”œâ”€ Sort IPs by frequency
  â”‚
  â”œâ”€ Identify high-risk IPs (3+)
  â”‚
  â”œâ”€ Determine risk level (HIGH/MEDIUM/LOW)
  â”‚
  â””â”€ Print comprehensive report

END

================================================================================
8. KEY RUST CONCEPTS USED
================================================================================

1. OWNERSHIP AND BORROWING
   - &str borrows a string without taking ownership
   - .clone() creates a copy when we need ownership
   - Prevents memory leaks and data races

2. OPTION<T> TYPE
   - Represents values that might not exist
   - Some(value) or None
   - Safer than null pointers

3. RESULT<T, E> TYPE
   - Represents operations that might fail
   - Ok(value) or Err(error)
   - Forces error handling

4. PATTERN MATCHING
   - if let Some(x) = ... â†’ Unwraps Option safely
   - if let Ok(x) = ... â†’ Unwraps Result safely
   - Compiler ensures all cases are handled

5. ITERATORS
   - .lines() â†’ Iterate over file lines
   - .iter() â†’ Iterate over collections
   - .filter() â†’ Keep items matching condition
   - .map() â†’ Transform items
   - .collect() â†’ Gather into collection

6. CLOSURES
   - |a, b| b.1.cmp(a.1) â†’ Anonymous function
   - Used for sorting, filtering, mapping
   - Captures variables from surrounding scope

7. HASHMAP
   - Key-value storage
   - O(1) lookup time
   - Entry API for efficient updates

8. THE ? OPERATOR
   - Early return on None or Err
   - Shorthand for error propagation
   - Makes code cleaner

================================================================================
9. EXAMPLE WALKTHROUGH
================================================================================

INPUT LOG LINE:
  "2024-01-15 10:30:45 [ERROR] Failed login attempt from 192.168.1.100 user: admin"

STEP 1: Parse with regex
  timestamp = "2024-01-15 10:30:45"
  level     = "ERROR"
  message   = "Failed login attempt from 192.168.1.100 user: admin"

STEP 2: Extract IP
  ip_address = Some("192.168.1.100")

STEP 3: Extract username
  username = Some("admin")

STEP 4: Create LogEntry
  LogEntry {
    timestamp: "2024-01-15 10:30:45",
    level: "ERROR",
    ip_address: Some("192.168.1.100"),
    username: Some("admin"),
    message: "Failed login attempt from 192.168.1.100 user: admin"
  }

STEP 5: Threat Detection
  âœ… Failed login detected (ERROR + "Failed login")
     â†’ failed_logins += 1

  âŒ Not a root attempt (username is "admin", not "root")

  âŒ No suspicious file access

  âŒ Not critical (level is ERROR, not CRITICAL)

STEP 6: IP Tracking
  ip_frequency["192.168.1.100"] += 1

RESULT:
  - failed_logins counter increased
  - IP 192.168.1.100 tracked in HashMap
  - Entry printed to console

================================================================================
10. PERFORMANCE CHARACTERISTICS
================================================================================

TIME COMPLEXITY:
  - File reading: O(n) where n = number of lines
  - Regex matching: O(m) where m = line length
  - HashMap updates: O(1) average case
  - Sorting IPs: O(k log k) where k = unique IPs
  - Overall: O(n * m + k log k)

SPACE COMPLEXITY:
  - LogEntry structs: O(n)
  - HashMap: O(k) where k = unique IPs
  - Sorted vector: O(k)
  - Overall: O(n + k)

OPTIMIZATIONS:
  - BufReader for efficient file I/O
  - HashMap for O(1) IP lookups
  - Entry API to avoid double lookups
  - Early returns with ? operator

================================================================================
11. POTENTIAL IMPROVEMENTS
================================================================================

1. Command-line arguments
   - Accept file path as argument
   - Configurable thresholds

2. Export results
   - JSON output format
   - CSV for spreadsheets
   - HTML reports

3. Real-time monitoring
   - Watch log files for changes
   - Stream processing

4. Advanced detection
   - Time-based analysis (attacks per minute)
   - Geolocation of IPs
   - Machine learning anomaly detection

5. Performance
   - Parallel processing for multiple files
   - Async I/O for large files
   - Compiled regex patterns (cache)

6. Error handling
   - Graceful handling of malformed lines
   - Detailed error reporting
   - Logging of parsing failures

================================================================================
12. SECURITY CONSIDERATIONS
================================================================================

WHAT THIS TOOL DETECTS:
  âœ… Brute force attacks (multiple failed logins)
  âœ… Privilege escalation attempts (root access)
  âœ… Credential theft (sensitive file access)
  âœ… Critical system events

WHAT IT DOESN'T DETECT (YET):
  âŒ SQL injection
  âŒ Cross-site scripting (XSS)
  âŒ DDoS attacks
  âŒ Malware signatures
  âŒ Network anomalies

LIMITATIONS:
  - Only as good as the log data
  - Can't detect attacks not logged
  - Threshold-based (may miss sophisticated attacks)
  - No context from other systems

================================================================================
END OF EXPLANATION
================================================================================
